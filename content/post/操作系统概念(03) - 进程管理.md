---
title: "操作系统概念(03) - 进程管理"
date: 2021-06-16T11:29:12+08:00
draft: false
tags: ["操作系统"]
---

# 进程管理



# 1. 进程概念

PCB，程序段，数据段三部分构成了进程实体

进程状态：

- 运行态：占有cpu,并且就在cpu上执行。

- 就绪态：进程等待分配cpu（也就是cpu没有调度到它）

- 等待态：等待某个事件发生（如io完成或收到信号）

还有两个状态：

- 创建态
- 终止态

**PCB：系统系统为每个运行的程序排至一个数据结构，称为进程控制块**

PCB包含进程相关信息：

- 进程状态
- 进程计数器：要执行的下个指令的地址
- CPU寄存器：状态信息在中断时要保存下来，方便进程以后能继续执行
- CPU调度信息：包含进程优先级，调度队列指针等
- 内存管理信息



# 2. 进程调度

调度队列

- 作业队列：包含所有进程

- 就绪队列：驻留在内存中就绪、等待运行的进程保存在这个队列。用循环链表表示，头节点指向链表第一个和最后一个PCB块的指针。
- 设备队列：进程向磁盘发送IO请求，由于系统有很多进程，磁盘可能忙于其他IO请求，该进程就需要等待磁盘。等待IO设备的队列叫做设备队列。



<img src="https://cdn.jsdelivr.net/gh/qiaocci/img-repo@master/20210616115744.png" style="zoom:80%;" />

调度程序

长期调度程序：频繁执行

短期调度程序：不频繁



什么是中断?

> 说到中断还不得不从现代操作系统的特性说起，无论是桌面PC操作系统还是嵌入式都是多任务的操作系统，而很遗憾，处理器往往是单个的，即使在硬件成本逐渐下降，从而硬件配置直线上升的今天，ＰＣ机的核心可能已经达到４核心，８核心，而手机移动设备更不可思议的达到16核心，32核心，处理器的数量依然不可能做到每个任务一个CPU，所以CPU必须作为一种全局的资源让所有任务共享。说到共享，如何共享呢？什么时候给任务A用，什么时候给任务B用......这就是进程调度，具体的安排就由调度算法决定了。进程如何去调度？现代操作系统一般都是采用基于时间片的优先级调度算法，把CPU的时间划分为很细粒度的时间片，一个任务每次只能时间这么多的时间，时间到了就必须交出使用权，即换其他的任务使用。这种要看操作系统的定时器机制了。那么时间片到之后，系统做了什么呢？这就要用到我们的中断了，时间片到了由定时器触发一个软中断，然后进入相应的处理历程。当然这一点不足以表明中断的重要，计算机操作系统自然离不开外部设备：鼠标、键盘、网卡、磁盘等等。就拿网卡来讲，我计算机并不知道时候数据包会来到，我能保证的就是数据来了我能正常接收就行了。但是我又不可能一直等着接收数据包，要是这样其他任务就死完了。所以合理的办法是，你数据包来到之后，通知我，然后我再对你处理，怎么通知呢？？答：中断！键盘、鼠标亦是如此！

 当发生一个中断时，系统需要保存当前运行在CPU中进程的上下文，从而在其处理完后能恢复上下文，即先中断进程，之后再继续。进程上下文用PCB表示，它保存CPU的寄存器，进程状态等信息。

上下文切换：将CPU切换到另一个进程需要保存当前进程的状态，并恢复另一个进程状态。这一任务切换成为上下文切换。发生上下文切换时，内核会将旧进程的装填保存在其PCB中，然后装入经调度要执行的新进程的PCB。上下文切换的时间是额外的开销，切换时系统不能做什么有用的工作。



# 3. 进程操作

## 3.1进程创建

是什么：进程在其执行过程中，可以创建多个新进程。创建进程称为父进程，新进程称为子进程。

操作系统根据唯一**进程标识符(PID)**来识别进程。

使用 fork 系统调用创建进程

- fork 系统调用是用于**创建进程**的
- fork 创建的进程**初始化状态**是和父进程一样的(进程有进程空间、内存、内存态等)
- 系统会为 fork 的进程分配新的资源(包括内存资源、CPU 资源等)
- fork 系统调用**无参数**
- fork 会**返回两次**，分别返回子进程 id 和 0(第一次是由父进程返回的，第二次由子进程所返回的，因此返回了两次)
- **返回子进程 id 的是父进程，返回 0 的是子进程**

调用 fork 之后，我们就可以根据返回值是否为 0 来判断是父进程还是子进程返回的

代码示例：

```cpp
#include<iostream>
#include<cstring>
#include<stdio.h>
#include<unistd.h>

using namespace std;

int main()

    pid_t pid;
    pid = fork();
    if(pid == 0) {
        cout << "这是一个子进程" << endl;
    }
    else if(pid > 0) {
        cout << "这是一个父进程" << endl;
        cout << "子进程id：" << pid << endl;
    }
    else if(pid < 0 ){
        cout << "创建进程失败" << endl;
    }
    return 0;
}
```

运行结果：

<img src="https://cdn.jsdelivr.net/gh/qiaocci/img-repo@master/20210616145457.png" style="zoom:80%;" />

从运行结果可以看到，fork 确实是返回了两次，两个 if 里边都走到了

在前边也说到，当 fork 创建一个子进程的时候，这个子进程的初始化内存状态是和父进程一样的，下边也用代码验证一下：

```cpp
#include<iostream>
#include<cstring>
#include<stdio.h>
#include<unistd.h>

using namespace std;

int main()
{
    pid_t pid;
    int num = 888;
    pid = fork();
    if(pid == 0) {
        cout << "这是一个子进程" << endl;
        cout << "num in son process："<< num << endl;
        while(true) {
            num+=1;
            cout << "num in son process："<< num << endl;
            sleep(1);
        }
    }
    else if(pid > 0) {
        cout << "这是一个父进程" << endl;
        cout << "子进程id：" << pid << endl;
        cout << "num in father process："<< num << endl;
        while(true) {
            num-=1;
            cout << "num in father process："<< num << endl;
            sleep(1);
        }
    }
    else if(pid < 0 ){
        cout << "创建进程失败" << endl;
    }
    return 0;
}
```

运行结果：

<img src="https://cdn.jsdelivr.net/gh/qiaocci/img-repo@master/20210616145618.png" style="zoom: 67%;" />



从图中可以看到子进程的初始值是和父进程是一样的，然后随着父进程和子进程执行的逻辑不一样，他们的 num 值就分道扬镳了。也就是说**初始化的状态，子进程的内存空间和父进程的内存空间是一样的，但是随着他们的逻辑走向不一样，他们的内存空间将走向不一样**

在快速变化的技术中寻找不变，才是一个技术人的核心竞争力。知行合一，理论结合实践

参考： https://xie.infoq.cn/article/c0d9a809d7cb57f29432e22f3



## 3.2 进程终止

当进程完成执行最后语句并使用exit请求操作系统删除自身时，进程终止。此时，进程可以返回状态值到父进程（通过系统调用wait())。

其他情况也会出现终止。例如父进程可以通过系统调用，终止子进程。父进程需要知道子进程pid，所以当进程创建新进程时，新进程的pid要传递给父进程。

为什么要终止子进程？

- 子进程使用超过它所分配的资源
- 分配给子进程的任务不再需要
- 父进程退出。父进程退出后，操作系统不允许子进程继续执行。

